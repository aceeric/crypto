# crypto

This is a C# DLL project that is used by other C# projects in my repo. It provides basic protection for sensitive information that has to be stored in plain text.

The basic use case is: you have a console utility that accesses an AWS resource - and the console utility needs a key and secret key. This console utility is run from a PowerShell script that - in turn - is run from a scheduled Job. So the PowerShell script needs to provide the utility with these secrets, but the script is sitting on the file system. Yes it's protected by user security. But you wand additional protection. So to additionally protect these secrets, in the PowerShell script you provide those credentials in encrypted form. The console utility includes this crypto DLL and uses the DLL to decrypt the provided credentials so it can access the bucket.

Here is how I use it:

As a preparatory step, said console utility provides a command line option to first encrypt a secret and give it to the user (assumed to be an SA with privileged access). E.g.:

```
my-console-utility -encrypt aws-access-key YOURACTUALAWSACCESSKEY
```

Under the covers your utility detects that the `-encrypt` option was specified on the command line and accesses the crypto DLL using the `Protect` method to convert the plain text to an encrypted string value. It emanates the encrypted value to the console:

```
private static void EncryptSecret(string Secret)
{
    Console.WriteLine(Crypto.Protect(Secret));
}
```

Assuming you have this in place, now you can run your utility with the `-encrypt` option specified, and you get this output generated by the utility using the  `crypto` DLL:

```
C:> my-console-utility -encrypt aws-access-key YOURACTUALAWSACCESSKEY
0x01000000D08C9DDF0115D1118C7A00C04FC297EB0100000084B3BA3DD1E11440896B8643B8CD670E04000000020000000000106600000001000020000000853068EE82867B95802EB9B7AF4EB8590D28B0A7432C589AC9D41512A0DC0A39000000000E8000000002000020000000440597169A037D8389B537C6FAE5AE4E19D2BC0B7DA61DF7DD26282DD0EBFAB2100000006DB5AA10463363183EF35B3A1B04AF9A40000000A76E9CBE5539C9C55F48A9F0492E23158202A1828F1C3FC9172986D0405DEB4EF4FEE7FD5F5E1D7200984662BC379849955CFE24A8C19592438BD968B957C066
```

Now, we assume your console utility also supports an `-encrypted` command line option indicating that secrets are passed as encrypted values rather than plain text:

```
C:> my-console-utility -encrypted aws-access-key 0x01000000D08C9DDF0115D1118C7A00C04FC297EB0100000084B3BA3DD1E11440896B8643B8CD670E04000000020000000000106600000001000020000000853068EE82867B95802EB9B7AF4EB8590D28B0A7432C589AC9D41512A0DC0A39000000000E8000000002000020000000440597169A037D8389B537C6FAE5AE4E19D2BC0B7DA61DF7DD26282DD0EBFAB2100000006DB5AA10463363183EF35B3A1B04AF9A40000000A76E9CBE5539C9C55F48A9F0492E23158202A1828F1C3FC9172986D0405DEB4EF4FEE7FD5F5E1D7200984662BC379849955CFE24A8C19592438BD968B957C066
```

And then in your C# utility (pseudo-code):

```
string accessKey = however you project the key value into your util from the cmd line;
if (your utility determines that the -encrypted option was specified)
{
    accessKey = Crypto.Unprotect(accessKey);
}
```

Now, `accessKey` is the decrypted value that you can pass to the AWS libs:

```
IAmazonS3 client = AWSClientFactory.CreateAmazonS3Client(accessKey, ...);
```

And that's it!

